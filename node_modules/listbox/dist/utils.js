"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNextDomItem = exports.focusElement = exports.isDescendantListbox = exports.getDeepestChild = void 0;

var _constants = require("./constants");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var getDeepestChild = function getDeepestChild(node) {
  if (typeof node.props.children === "string") {
    return node.props.children;
  } else {
    return getDeepestChild(node.props.children);
  }
};

exports.getDeepestChild = getDeepestChild;

var isDescendantListbox = function isDescendantListbox(node) {
  var role = node.getAttribute("role");

  if (role === "listbox" || role === "combobox") {
    return true;
  }

  if (node.parentElement === null) {
    return false;
  }

  return isDescendantListbox(node.parentElement);
};

exports.isDescendantListbox = isDescendantListbox;

var focusElement = function focusElement(element, container) {
  var scrollBottom = container.clientHeight + container.scrollTop;
  var elementBottom = element.offsetTop + element.offsetHeight;

  if (elementBottom > scrollBottom) {
    container.scrollTop = elementBottom - container.clientHeight;
  } else if (element.offsetTop < container.scrollTop) {
    container.scrollTop = element.offsetTop;
  }
}; // getNextDomItem is used to find the next active DOM node when a user presses
// on keys in the context of a listbox. Pressing arrow keys (up & down on a
// vertical listbox) should navigate the user to the previous and next DOM
// nodes respectively. When a user presses an alpha-numeric key, this function
// should return the (text) node that starts with the typed character(s).


exports.focusElement = focusElement;

var getNextDomItem = function getNextDomItem(_ref) {
  var event = _ref.event,
      activeNode = _ref.activeNode,
      findTypedInDomNodes = _ref.findTypedInDomNodes;
  var nextItem;

  switch (event.which) {
    // When a user presses ArrowUp or ArrowDown, we want to return the next element.
    // If the user is already on the first element and they press ArrowUp or on the
    // last element and they press ArrowDown, this function returns null.
    case _constants.KEY_CODE.up:
    case _constants.KEY_CODE.down:
      event.preventDefault();

      if (event.which === _constants.KEY_CODE.up) {
        nextItem = activeNode.previousElementSibling;
      } else {
        nextItem = activeNode.nextElementSibling;
      }

      break;

    default:
      {
        // When the user types in an alpha-numeric character(s), an list of domNodes
        // is filtered with the typed characters to find the next item. E.g. if we
        // had three text elements: ford, toyota, tesla, and the user types "te",
        // then next item will be "tesla". So the node that contains "tesla" is returned.
        var domNodes = _toConsumableArray(event.target.children[0].children);

        nextItem = findTypedInDomNodes(event.which, domNodes);
      }
  }

  return nextItem;
};

exports.getNextDomItem = getNextDomItem;